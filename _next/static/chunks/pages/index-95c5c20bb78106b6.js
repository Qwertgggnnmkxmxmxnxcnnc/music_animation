(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{8312:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return t(6874)}])},6874:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return c}});var i=t(5893),s=t(7294),l=t(2590),a=t(7133),o=t(8113),r=e=>{let{width:n=500,height:t=500,isDarkMode:r,animationType:c,audioAnalyser:d}=e,u=(0,s.useRef)(null),p=(0,s.useRef)(void 0),f=(0,s.useRef)(null),m=e=>{let n=()=>{var t;if((null===(t=f.current)||void 0===t?void 0:t.material)&&e){let n=new Uint8Array(e.frequencyBinCount);e.getByteFrequencyData(n);let t=n.slice(0,4).reduce((e,n)=>e+n)/4,i=n.slice(4,12).reduce((e,n)=>e+n)/8,s=n.slice(12,20).reduce((e,n)=>e+n)/8;f.current.material.uniforms.audio.value=Math.min((.5*t+.3*i+.2*s)/255*.8,.8)}requestAnimationFrame(n)};n()};return(0,s.useEffect)(()=>{if(!u.current)return;let e=new a.xsS;e.background=new a.Ilk(r?0:16777215);let i=new a.cPb(75,n/t,.1,1e3),s=new o.CP7({canvas:u.current,antialias:!0,alpha:!0,precision:"highp",powerPreference:"high-performance"});s.setPixelRatio(Math.min(window.devicePixelRatio,2)),i.position.z=2,s.setSize(n,t);let d=(0,l.sculptToThreeJSMesh)(1===c?"\n      // Анимация 1\n      rotateY(time * 0.2);\n      \n      let scale = input(1., 0.0, 10.);\n      let s = getSpace();\n      let audio = input();\n\n      let n = noise(s * scale + vec3(0, 0, time) + noise(s * scale + vec3(0, 0, time)));\n\n      setStepSize(0.2);\n      setGeometryQuality(12);\n      setMaxIterations(300);\n\n      metal(1.0);\n      shine(1.0);\n      fresnel(1.0);\n      lightDirection(0.5, 1.0, 0.3);\n      lightDirection(-0.5, -0.5, 0.5);\n\n      let nscale = input(1.2, 0, 10);\n      let hueOffset = input(0.03, 0, 0.1);\n      let rings = input(4, 0, 100);\n\n      let dir1 = vec3(sin(time * 0.3), cos(time * 0.4), sin(time * 0.5));\n      let dir2 = vec3(cos(time * 0.2), sin(time * 0.3), cos(time * 0.4));\n      let dir3 = vec3(sin(time * 0.4), cos(time * 0.5), sin(time * 0.3));\n\n      let baseFreq = 15.0 + audio * 20.0;\n      let waveIntensity = audio * 1.5;\n      \n      let normalizedPos = normalize(s);\n      let waves = \n        sin(dot(normalizedPos, normalize(dir1)) * baseFreq + time * 2.0) * 0.4 +\n        sin(dot(normalizedPos, normalize(dir2)) * (baseFreq * 0.5) + time * -1.5) * 0.3 +\n        sin(dot(normalizedPos, normalize(dir3)) * (baseFreq * 0.25) - time) * 0.2;\n      \n      waves *= waveIntensity * smoothstep(1.2, 0.8, length(s));\n      \n      let warpedSpace = warpSpace(s);\n      let samplePos = warpedSpace * nscale + vec3(0, 0, -time) * 0.2;\n      \n      let audioHue = time * 0.1 + audio * 2.0;\n      let n1 = nsin((noise(samplePos)) * rings + audioHue);\n      let n2 = nsin((noise(samplePos + hueOffset)) * rings + audioHue * 1.5);\n      let n3 = nsin((noise(samplePos + hueOffset * 2)) * rings + audioHue * 2.0);\n      \n      let audioEffect = audio * 2.0;\n      let col = pow(vec3(n1, n2, n3), vec3(3.0 + audioEffect));\n      \n      let pulseColor = vec3(\n        sin(audioHue) * 0.5 + 0.5,\n        sin(audioHue * 1.2) * 0.5 + 0.5,\n        sin(audioHue * 1.4) * 0.5 + 0.5\n      );\n\n      let metalBase = vec3(0.95, 0.97, 1.0);\n      let metalColor = mix(col, pulseColor, audio * 0.3) + normal * 0.3;\n      color(metalColor * metalBase);\n\n      let baseRadius = 0.9;\n      let displacement = n * 0.03 + waves * mix(0.02, 0.08, audio);\n      sphere(baseRadius + displacement);\n\n      function warpSpace(s) {\n        let strength = 0.14 + audio * 0.05;\n        let twistMix = 0.01 + audio * 0.01;\n        let t = time / 4.;\n        \n        s = s * 16.0 * (vec3(0.5, 0.2, 0.1) + s);\n        \n        let waveCount = 3.0 + audio * 6.0;\n        for (let i = 1.0; i < waveCount; i += 1.0) {\n          let randOffset = noise(vec3(i, t, 0.0)) * 2.0;\n          let waveMod = sin(t * 0.5 + i + randOffset) * 0.5;\n          s.x = s.x + strength * sin(2.0 * t + i * 1.5 * s.y + waveMod + randOffset) + t * 0.3;\n          s.y = s.y + strength * cos(2.0 * t + i * 2.5 * s.x + waveMod + randOffset);\n          s.z = s.z + strength * sin(1.5 * t + i * 2.0 * s.z + waveMod + randOffset);\n        }\n        return 0.75 + 0.5 * cos(time + vec3(s.x, s.y, s.x) + vec3(0.0, 2.0, 4.0));\n      }\n    ":2===c?"\n      // Анимация 2\n      rotateY(time * 0.2);\n      let scale = input(1., 0.0, 10.);\n      let s = getSpace();\n      let audio = input();\n\n      let n = noise(s * scale + vec3(0, 0, time));\n\n      metal(1.0);\n      shine(1.0);\n      fresnel(1.0);\n      lightDirection(0.5, 1.0, 0.3);\n      lightDirection(-0.5, -0.5, 0.5);\n\n      setStepSize(0.3);\n      setGeometryQuality(8);\n      setMaxIterations(150);\n\n      let waveIntensity = 0.3 + audio * 1.2;\n      let baseFreq = 10.0 + audio * 10.0;\n\n      let dir1 = vec3(1.0, 0.0, 0.0);\n      let dir2 = vec3(0.0, 1.0, 0.0);\n      let waves = sin(dot(normalize(s), dir1) * baseFreq + time) * 0.1;\n      waves += sin(dot(normalize(s), dir2) * (baseFreq * 0.5) + time * -1.0) * 0.1;\n\n      let hue = time * 0.1 + audio * 2.0;\n      let col = vec3(\n        sin(hue) * 0.5 + 0.5,\n        sin(hue + 2.0) * 0.5 + 0.5,\n        sin(hue + 4.0) * 0.5 + 0.5\n      );\n\n      let metalColor = col * (0.8 + normal * 0.2);\n      color(metalColor);\n\n      let baseRadius = 0.8 + waves;\n      let displacement = n * 0.05;\n      sphere(baseRadius + displacement);\n    ":3===c?"\n      // Третья анимация\n      rotateY(time * 0.2);\n\n      let scale = input(1., 0.0, 10.);\n      let s = getSpace();\n      let audio = input();\n\n      let n = noise(s * scale + vec3(0, 0, time) + noise(s * scale + vec3(0, 0, time)));\n\n      setStepSize(0.2);\n      setGeometryQuality(12);\n      setMaxIterations(300);\n\n      metal(1.0);\n      shine(1.0);\n      fresnel(1.0);\n      lightDirection(0.5, 1.0, 0.3);\n      lightDirection(-0.5, -0.5, 0.5);\n\n      let nscale = input(1.2, 0, 10);\n      let hueOffset = input(0.03, 0, 0.1);\n      let rings = input(4, 0, 100);\n\n      let dir1 = vec3(sin(time * 0.3), cos(time * 0.4), sin(time * 0.5));\n      let dir2 = vec3(cos(time * 0.2), sin(time * 0.3), cos(time * 0.4));\n      let dir3 = vec3(sin(time * 0.4), cos(time * 0.5), sin(time * 0.3));\n\n      let baseFreq = 15.0 + audio * 40.0;\n      let waveIntensity = audio * 2.0;\n\n      let normalizedPos = normalize(s);\n      let waves = \n        sin(dot(normalizedPos, normalize(dir1)) * baseFreq + time * 2.0) * 0.5 +\n        sin(dot(normalizedPos, normalize(dir2)) * (baseFreq * 0.5) + time * -1.5) * 0.4 +\n        sin(dot(normalizedPos, normalize(dir3)) * (baseFreq * 0.25) - time) * 0.3;\n\n      waves *= waveIntensity * smoothstep(1.2, 0.8, length(s));\n\n      let warpedSpace = warpSpace(s);\n      let samplePos = warpedSpace * nscale + vec3(0, 0, -time) * 0.2;\n\n      let audioHue = time * 0.2 + audio * 3.0;\n      let n1 = nsin((noise(samplePos)) * rings + audioHue);\n      let n2 = nsin((noise(samplePos + hueOffset)) * rings + audioHue * 1.5);\n      let n3 = nsin((noise(samplePos + hueOffset * 2)) * rings + audioHue * 2.0);\n\n      let audioEffect = audio * 3.0;\n      let col = pow(vec3(n1, n2, n3), vec3(3.0 + audioEffect));\n\n      let pulseColor = vec3(\n        sin(audioHue) * 0.5 + 0.5,\n        sin(audioHue * 1.2) * 0.5 + 0.5,\n        sin(audioHue * 1.4) * 0.5 + 0.5\n      );\n\n      let metalBase = vec3(0.95, 0.97, 1.0);\n      let metalColor = mix(col, pulseColor, audio * 0.4) + normal * 0.4;\n      color(metalColor * metalBase);\n\n      let baseRadius = 0.9;\n      let displacement = n * 0.05 + waves * mix(0.04, 0.12, audio);\n      sphere(baseRadius + displacement);\n\n      function warpSpace(s) {\n        let strength = 0.2 + audio * 0.08;\n        let twistMix = 0.02 + audio * 0.02;\n        let t = time / 4.;\n        \n        s = s * 16.0 * (vec3(0.5, 0.2, 0.1) + s);\n\n        let waveCount = 3.0 + audio * 6.0;\n        for (let i = 1.0; i < waveCount; i += 1.0) {\n          let randOffset = noise(vec3(i, t, 0.0)) * 2.0;\n          let waveMod = sin(t * 0.5 + i + randOffset) * 0.5;\n          s.x = s.x + strength * sin(2.0 * t + i * 1.5 * s.y + waveMod + randOffset) + t * 0.3;\n          s.y = s.y + strength * cos(2.0 * t + i * 2.5 * s.x + waveMod + randOffset);\n          s.z = s.z + strength * sin(1.5 * t + i * 2.0 * s.z + waveMod + randOffset);\n        }\n        return 0.75 + 0.5 * cos(time + vec3(s.x, s.y, s.x) + vec3(0.0, 2.0, 4.0));\n      }\n    ":4===c?"\n      // Четвертая анимация\n      let offsetScale = input(0, 0, 3);\n\nsetMaxReflections(1);\n\nfunction checkers(dpdx, dpdy, scale) {\n  let s = getSpace();\n\n  s.y += nsin(s.x * 2 + time * 0.5) * offsetScale;\n  s = s * scale;\n  let p = vec2(s.x, s.y);\n  let w = vec2(max(abs(dpdx.x), abs(dpdy.x)), max(abs(dpdx.y), abs(dpdy.y)));\n  let i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) -\n                 abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n  return 0.5 - 0.5 * i.x * i.y;                  \n}\n\nlet s = getSpace();\nlet audio = input(); // Аудио-сигнал в диапазоне от 0 до 1\n\n// Используем аудио для параметра mixG\nlet mixG = clamp(audio, 0.0, 1.0);\n\nlet n = vectorContourNoise(s * 2 + vec3(0, 0, time * 0.1), 0.04, 1.2);\nn = pow(sin(n * 2) * 0.5 + 0.5, vec3(10));\n\n// Настройки рендеринга\nsetStepSize(0.2);\nlet gridOffset = PI;\nlet start = vec2(0.1, 0.1);\nlet end = vec2(2 * ncos(gridOffset), 2 * ncos(gridOffset));\nlet scale = 4.9;\n\nlet check = checkers(start, end, scale);\nlet col = check + n;\n\nshine(0.9);\nocclusion(0.1);\n\n// Цвет и отражения\ncolor(col);\nreflectiveColor(vec3(0.1) + col * 0.5);\n\n// Основная форма с реакцией на аудио\nshape(() => {\n  displace(0, 0, 0.2);\n  rotateX(PI / 2);\n  rotateX(time);\n  rotateY(time);\n  box(vec3(0.6));\n  mixGeo(mixG); // Используем mixG, который изменяется в зависимости от audio\n  sphere(0.6);\n})();\n\n// Дополнительная форма\nlet d = getSDF();\nunion();\nshape(() => {\n  let r = smoothstep(0.0, 2.0, sqrt(d));\n  let v = nsin(2.0 * d + 4.5) + 0.0;\n  color(vec3(v));\n  reflectiveColor(vec3(0));\n  sphere(4.0);\n  shell(0.1);\n})();\n\n    ":5===c?"\n      // Пятая анимация\n      // Идея от https://www.iquilezles.org/www/articles/warp/warp.html\nsetMaxIterations(1);\n\n// Параметры для управления\nlet scale = input(0.5); // Базовый масштаб\nlet offset = input(0.08, 0, 0.1);\n\n// Функция fbm для шума\nfunction fbm(p) {\n  return vec3(\n    noise(p),\n    noise(p + offset),\n    noise(p + offset * 2)\n  );\n}\n\n// Получаем направление луча\nlet s = getRayDirection();\n\n// Получаем аудиосигнал\nlet audio = input(); // Значение от 0 до 1, зависящее от музыки\n\n// Добавляем реакцию на звук: масштаб зависит от аудио\ns *= scale + audio * 0.2;\n\n// Генерация шума с реакцией на звук\nlet n = sin(fbm(fbm(fbm(fbm(s + vec3(0, 0, -time * 0.01)))))) * 2.0 * 0.5 + 0.75;\nn = pow(n, vec3(6));\n\n// Применяем цвет на основе шума\ncolor(n);\n\n// Сфера с изменением радиуса в зависимости от аудио\nsphere(1.0 + n.x * 0.05 + audio * 0.2);\n\n    ":"\n      // Fallback анимация\n      sphere(1.0);\n    ",{time:!0,audio:!0});f.current=d,e.add(d);let m=()=>{p.current=requestAnimationFrame(m),d.material&&(d.material.uniforms.time.value+=.01),s.render(e,i)};return m(),()=>{p.current&&cancelAnimationFrame(p.current),s.dispose()}},[n,t,r,c]),(0,s.useEffect)(()=>{d&&m(d)},[d]),(0,i.jsx)("div",{children:(0,i.jsx)("canvas",{ref:u,width:n,height:t,style:{display:"block"}})})};function c(){let[e,n]=(0,s.useState)(!1),[t,l]=(0,s.useState)(1),[a,o]=(0,s.useState)({width:500,height:500}),c=(0,s.useRef)(null),[d,u]=(0,s.useState)(null),[p,f]=(0,s.useState)(null),[m,h]=(0,s.useState)(!1);(0,s.useEffect)(()=>{h(!0);let e=()=>{o({width:Math.min(window.innerWidth-40,500),height:Math.min(window.innerWidth-40,500)})};return e(),window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)},[]);let v=async e=>{var n;let t=null===(n=e.target.files)||void 0===n?void 0:n[0];if(t&&c.current){let e=URL.createObjectURL(t);if(c.current.src=e,!d){let e=new AudioContext,n=e.createMediaElementSource(c.current),t=e.createAnalyser();t.fftSize=512,t.smoothingTimeConstant=.6,t.minDecibels=-70,t.maxDecibels=-30,n.connect(t),t.connect(e.destination),u(e),f(t)}try{await c.current.play(),(null==d?void 0:d.state)==="suspended"&&await d.resume()}catch(e){console.error("Ошибка воспроизведения:",e)}}};return m?(0,i.jsxs)("div",{style:{minHeight:"100vh",display:"flex",flexDirection:"column",backgroundColor:e?"#000000":"#ffffff",transition:"background-color 0.3s ease"},children:[(0,i.jsxs)("header",{style:{padding:"20px",display:"flex",justifyContent:"flex-end",gap:"20px",position:"fixed",top:0,right:0,zIndex:1e3},children:[(0,i.jsxs)("select",{value:t,onChange:e=>l(Number(e.target.value)),style:{padding:"8px 12px",borderRadius:"20px",border:"2px solid ".concat(e?"#ffffff":"#000000"),background:"transparent",color:e?"#ffffff":"#000000",cursor:"pointer",fontSize:"16px",outline:"none"},children:[(0,i.jsx)("option",{value:1,children:"Анимация 1"}),(0,i.jsx)("option",{value:2,children:"Анимация 2"}),(0,i.jsx)("option",{value:3,children:"Анимация 3"}),(0,i.jsx)("option",{value:4,children:"Анимация 4"}),(0,i.jsx)("option",{value:5,children:"Анимация 5"})]}),(0,i.jsx)("button",{onClick:()=>n(!e),style:{padding:"10px",background:e?"#ffffff":"#000000",color:e?"#000000":"#ffffff",border:"none",borderRadius:"50%",cursor:"pointer",width:"40px",height:"40px",display:"flex",alignItems:"center",justifyContent:"center",fontSize:"20px"},children:e?"☀️":"\uD83C\uDF19"})]}),(0,i.jsxs)("main",{style:{flex:1,display:"flex",flexDirection:"column",alignItems:"center",padding:"20px",gap:"40px"},children:[m&&(0,i.jsx)(r,{isDarkMode:e,animationType:t,width:a.width,height:a.height,audioAnalyser:p}),(0,i.jsxs)("div",{style:{display:"flex",flexDirection:"column",alignItems:"center",gap:"20px",marginTop:"20px"},children:[(0,i.jsx)("div",{style:{display:"flex",gap:"10px",alignItems:"center"},children:(0,i.jsx)("label",{htmlFor:"audio-input",style:{padding:"10px",background:"#4CAF50",color:"white",borderRadius:"50%",cursor:"pointer",width:"40px",height:"40px",display:"flex",alignItems:"center",justifyContent:"center"},children:(0,i.jsxs)("svg",{width:"24",height:"24",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",children:[(0,i.jsx)("path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"}),(0,i.jsx)("polyline",{points:"17 8 12 3 7 8"}),(0,i.jsx)("line",{x1:"12",y1:"3",x2:"12",y2:"15"})]})})}),(0,i.jsx)("input",{type:"file",accept:"audio/*",onChange:v,style:{display:"none"},id:"audio-input"}),(0,i.jsx)("audio",{ref:c,controls:!0,onPlay:()=>{(null==d?void 0:d.state)==="suspended"&&d.resume()},style:{width:"300px",borderRadius:"20px",backgroundColor:e?"#333":"#fff",color:e?"#fff":"#000"}})]})]})]}):null}}},function(e){e.O(0,[774,737,934,803,888,179],function(){return e(e.s=8312)}),_N_E=e.O()}]);